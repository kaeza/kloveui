
---
-- Core functions.
--
-- This module also exports all widgets itself so users don't need to import
-- each sub-module separately.
--
-- @module simpleui

local simpleui = { }

local gfx = love.graphics

local name = ...

for _, m in ipairs({
	"Widget",
	"Label",
	"Image",
	"Button",
	"Check",
	"Option",
	"Box",
	"Entry",
	"Slider",
}) do
	simpleui[m] = require(name.."."..m)
end

---
-- Table used to represent a color.
--
-- All components are numbers in the range 0 to 255 (inclusive).
--
-- @table Color
-- @tfield number 1 Red component.
-- @tfield number 2 Green component.
-- @tfield number 3 Blue component.
-- @tfield ?number 4 Alpha (transparency) component. 0 means fully
--  transparent, and 255 means fully opaque. Values in-between mean
--  partial transparency. If nil, defaults to 255.

---
-- Table used to represent border sizes.
--
-- Fields not specified default to 0.
--
-- @table Border
-- @tfield ?number l Left.
-- @tfield ?number t Top.
-- @tfield ?number r Right.
-- @tfield ?number b Bottom.

local rootwidget
local hoverwidget, mousewidget, mousewidgetx, mousewidgety
local focuswidget
local guiscale

---
-- Look up a widget by ID.
--
-- This is equivalent to calling `lookup` method on the root widget.
-- See the method's documentation for implementation details.
--
-- @tparam any id ID to look up.
-- @treturn simpleui.Widget|nil The widget if found, nil otherwise.
-- @see simpleui.Widget.id
-- @see simpleui.Widget:lookup
function simpleui.lookup(id)
	return rootwidget:lookup(id)
end

---
-- Called by the system to draw the GUI.
--
-- Set as same-named `love` callback by `run`.
function simpleui.draw()
	gfx.push()
	gfx.scale(guiscale, guiscale)
	rootwidget:draw()
	gfx.pop()
end

---
-- Called by the system to update the GUI logic.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number dtime Time since last call, in seconds.
function simpleui.update(dtime)
	rootwidget:update(dtime)
end

local function getmouse(x, y)
	local wid, rx, ry
	if mousewidget then
		wid, rx, ry = mousewidget, x-mousewidgetx, y-mousewidgety
	else
		wid, rx, ry = rootwidget:hittest(x, y)
	end
	return wid, rx, ry
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number x Mouse X.
-- @tparam number y Mouse Y.
-- @tparam number b Mouse button.
-- @tparam boolean istouch Whether the event was generated by a touch screen.
function simpleui.mousepressed(x, y, b, istouch)
	x, y = x/guiscale, y/guiscale
	local wid, rx, ry = getmouse(x, y)
	if wid then
		if wid.canfocus then
			simpleui.setfocus(wid)
		end
		mousewidget, mousewidgetx, mousewidgety = wid, wid:abspos()
		wid:mousepressed(rx, ry, b, istouch)
	end
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number x Mouse X.
-- @tparam number y Mouse Y.
-- @tparam number b Mouse button.
-- @tparam boolean istouch Whether the event was generated by a touch screen.
function simpleui.mousereleased(x, y, b, istouch)
	x, y = x/guiscale, y/guiscale
	local wid, rx, ry = getmouse(x, y)
	if wid then
		wid:mousereleased(rx, ry, b, istouch)
		mousewidget, mousewidgetx, mousewidgety = nil, nil, nil
	end
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number x Mouse X.
-- @tparam number y Mouse Y.
-- @tparam number dx Mouse X difference since last call.
-- @tparam number dy Mouse Y difference since last call.
-- @tparam boolean istouch Whether the event was generated by a touch screen.
function simpleui.mousemoved(x, y, dx, dy, istouch)
	x, y = x/guiscale, y/guiscale
	if mousewidget then
		mousewidget:mousemoved(x-mousewidgetx, y-mousewidgety,
				dx, dy, istouch)
	else
		local wid, rx, ry = getmouse(x, y)
		if wid ~= hoverwidget then
			if hoverwidget then
				hoverwidget:mouseleave()
			end
			hoverwidget = wid
			if wid then
				wid:mouseenter()
			end
		end
		if wid then
			wid:mousemoved(rx, ry, dx, dy, istouch)
		end
	end
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number dx Wheel X difference.
-- @tparam number dy Wheel Y difference.
function simpleui.wheelmoved(dx, dy)
	if mousewidget then
		mousewidget:wheelmoved(dx, dy)
	else
		local wid = getmouse(love.mouse.getPosition())
		if wid then
			wid:wheelmoved(dx, dy)
		end
	end
end

---
-- Called by the system to handle window resizes.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number w
-- @tparam number h
function simpleui.resize(w, h)
	w, h = w/guiscale, h/guiscale
	rootwidget:rect(0, 0, w, h)
end

---
-- Called by the system to handle keyboard input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam love.keyboard.KeyConstant key Key name.
-- @tparam boolean isrep Whether this event was generated due to key repeat.
function simpleui.keypressed(key, isrep)
	if focuswidget then
		focuswidget:keypressed(key, isrep)
	end
end

---
-- Called by the system to handle keyboard input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam love.keyboard.KeyConstant key Key name.
function simpleui.keyreleased(key)
	if focuswidget then
		focuswidget:keyreleased(key)
	end
end

---
-- Called by the system to handle keyboard input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam string text Text entered by the user.
function simpleui.textinput(text)
	if focuswidget then
		focuswidget:textinput(text)
	end
end

---
-- Set the input focus.
--
-- @tparam simpleui.Widget wid Widget that will receive the input focus.
-- @treturn simpleui.Widget|nil oldfocus The old input focus, or nil if no
--  widget had the input focus.
function simpleui.setfocus(wid)
	local old = focuswidget
	if old then
		old.focused = false
		old:focuslost()
	end
	focuswidget = wid
	if wid then
		wid.focused = true
		wid:focusgot()
	end
	return old
end

---
-- Get the widget that has the input focus.
--
-- @treturn simpleui.Widget|nil focus A widget, or nil if no widget has the
--  input focus.
function simpleui.getfocus()
	local old = focuswidget
	focuswidget = wid
	return old
end

local callbacks = {
	"draw",
	"update",
	"mousepressed",
	"mousereleased",
	"mousemoved",
	"wheelmoved",
	"keypressed",
	"keyreleased",
	"textinput",
	"resize",
}

---
-- Run the GUI.
--
-- Sets the specified widget as the "root" of the widget hierarchy, sets the
-- required `love` callbacks, then calls `love.run`. The LÃ–VE event loop then
-- takes care to call back into this module to handle events.
--
-- This method blocks until a "quit" event is received, and returns whatever
-- exit status is passed to `love.event.quit`.
--
-- @tparam simpleui.Widget root Root of the widget hierarchy.
-- @tparam ?number scale GUI scaling factor. Default is 1.
-- @treturn ?number App exit status (return value of `love.run`).
function simpleui.runsub(root, scale)
	local old = { }
	rootwidget = root
	guiscale = scale or 1
	mousewidget = nil
	focuswidget = nil
	for _, k in ipairs(callbacks) do
		old[k] = love[k]
		love[k] = simpleui[k]
	end
	local ww, wh = love.window.getMode()
	local hasrep = love.keyboard.hasKeyRepeat()
	love.keyboard.setKeyRepeat(true)
	simpleui.resize(ww, wh)
	local function bail(...)
		rootwidget = nil
		love.keyboard.setKeyRepeat(hasrep)
		for _, k in ipairs(callbacks) do
			love[k] = old[k]
		end
		return ...
	end
	return bail(love.run())
end

---
-- Run the GUI.
--
-- Equivalent to `love.event.quit(simpleui.runsub(...))`.
--
-- @tparam simpleui.Widget root Root of the widget hierarchy.
-- @tparam ?number scale GUI scaling factor. Default is 1.
function simpleui.run(root, scale)
	return love.event.quit(simpleui.runsub(root, scale))
end

return simpleui
