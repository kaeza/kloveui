
---
-- Core functions.
--
-- This module also exports all widgets itself so users don't need to import
-- each sub-module separately.
--
-- @module simpleui

local M = { }

local name = ...

for _, m in ipairs({
	"Widget",
	"Label",
	"Image",
	"Button",
	"Check",
	"Option",
	"Box",
	"Entry",
}) do
	M[m] = require(name.."."..m)
end

---
-- Table used to represent a color.
--
-- All components are numbers in the range 0 to 255 (inclusive).
--
-- @table Color
-- @tfield number 1 Red component.
-- @tfield number 2 Green component.
-- @tfield number 3 Blue component.
-- @tfield ?number 4 Alpha (transparency) component. 0 means fully
--  transparent, and 255 means fully opaque. Values in-between mean
--  partial transparency. If nil, defaults to 255.

---
-- Table used to represent border sizes.
--
-- Fields not specified default to 0.
--
-- @table Border
-- @tfield ?number l Left.
-- @tfield ?number t Top.
-- @tfield ?number r Right.
-- @tfield ?number b Bottom.

local rootwidget
local mousewidget, mousewidgetx, mousewidgety
local focuswidget

---
-- Look up a widget by ID.
--
-- This is equivalent to calling `lookup` method on the root widget.
-- See the method's documentation for implementation details.
--
-- @tparam any id ID to look up.
-- @treturn simpleui.Widget|nil The widget if found, nil otherwise.
-- @see simpleui.Widget.id
-- @see simpleui.Widget:lookup
function M.lookup(id)
	return rootwidget:lookup(id)
end

---
-- Called by the system to draw the GUI.
--
-- Set as same-named `love` callback by `run`.
function M.draw()
	rootwidget:draw()
end

---
-- Called by the system to update the GUI logic.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number dtime Time since last call, in seconds.
function M.update(dtime)
	rootwidget:update(dtime)
end

local function getmouse(x, y)
	local wid, rx, ry
	if mousewidget then
		wid, rx, ry = mousewidget, x-mousewidgetx, y-mousewidgety
	else
		wid, rx, ry = rootwidget:hittest(x, y)
	end
	return wid, rx, ry
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number x Mouse X.
-- @tparam number y Mouse Y.
-- @tparam number b Mouse button.
-- @tparam boolean istouch Whether the event was generated by a touch screen.
function M.mousepressed(x, y, b, istouch)
	local wid, rx, ry = getmouse(x, y)
	if wid then
		if wid.canfocus then
			M.setfocus(wid)
		end
		mousewidget, mousewidgetx, mousewidgety = wid, wid:abspos()
		wid:mousepressed(rx, ry, b, istouch)
	end
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number x Mouse X.
-- @tparam number y Mouse Y.
-- @tparam number b Mouse button.
-- @tparam boolean istouch Whether the event was generated by a touch screen.
function M.mousereleased(x, y, b, istouch)
	local wid, rx, ry = getmouse(x, y)
	if wid then
		wid:mousereleased(rx, ry, b, istouch)
		mousewidget, mousewidgetx, mousewidgety = nil, nil, nil
	end
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number x Mouse X.
-- @tparam number y Mouse Y.
-- @tparam number dx Mouse X difference since last call.
-- @tparam number dy Mouse Y difference since last call.
-- @tparam boolean istouch Whether the event was generated by a touch screen.
function M.mousemoved(x, y, dx, dy, istouch)
	if mousewidget then
		mousewidget:mousemoved(x-mousewidgetx, y-mousewidgety,
				dx, dy, istouch)
	else
		local wid, rx, ry = getmouse(x, y)
		if wid then
			wid:mousemoved(rx, ry, dx, dy, istouch)
		end
	end
end

---
-- Called by the system to handle mouse input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number dx Wheel X difference.
-- @tparam number dy Wheel Y difference.
function M.wheelmoved(dx, dy)
	if mousewidget then
		mousewidget:wheelmoved(dx, dy)
	else
		local wid = getmouse(love.mouse.getPosition())
		if wid then
			wid:wheelmoved(dx, dy)
		end
	end
end

---
-- Called by the system to handle window resizes.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam number w
-- @tparam number h
function M.resize(w, h)
	rootwidget:size(w, h)
end

---
-- Called by the system to handle keyboard input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam love.keyboard.KeyConstant key Key name.
-- @tparam boolean isrep Whether this event was generated due to key repeat.
function M.keypressed(key, isrep)
	if focuswidget then
		focuswidget:keypressed(key, isrep)
	end
end

---
-- Called by the system to handle keyboard input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam love.keyboard.KeyConstant key Key name.
function M.keyreleased(key)
	if focuswidget then
		focuswidget:keyreleased(key)
	end
end

---
-- Called by the system to handle keyboard input.
--
-- Set as same-named `love` callback by `run`.
--
-- @tparam string text Text entered by the user.
function M.textinput(text)
	if focuswidget then
		focuswidget:textinput(text)
	end
end

---
-- Set the input focus.
--
-- @tparam simpleui.Widget wid Widget that will receive the input focus.
-- @treturn simpleui.Widget|nil oldfocus The old input focus, or nil if no
--  widget had the input focus.
function M.setfocus(wid)
	local old = focuswidget
	if old then
		old.focused = false
		old:focuslost()
	end
	focuswidget = wid
	if wid then
		wid.focused = true
		wid:focusgot()
	end
	return old
end

---
-- Get the widget that has the input focus.
--
-- @treturn simpleui.Widget|nil focus A widget, or nil if no widget has the
--  input focus.
function M.getfocus(wid)
	local old = focuswidget
	focuswidget = wid
	return old
end

---
-- Run the GUI.
--
-- Sets the specified widget as the "root" of the widget hierarchy, sets the
-- required `love` callbacks, then returns. The top-level LÃ–VE event loop then
-- takes care to call back into this module to handle events.
--
-- @tparam simpleui.Widget root Root of the widget hierarchy.
function M.run(root)
	rootwidget = root
	mousewidget = nil
	focuswidget = nil
	love.draw = M.draw
	love.update = M.update
	love.mousepressed = M.mousepressed
	love.mousereleased = M.mousereleased
	love.mousemoved = M.mousemoved
	love.wheelmoved = M.wheelmoved
	love.keypressed = M.keypressed
	love.keyreleased = M.keyreleased
	love.textinput = M.textinput
	love.resize = M.resize
	local ww, wh = love.window.getMode()
	love.keyboard.setKeyRepeat(true)
	love.resize(ww, wh)
end

return M
